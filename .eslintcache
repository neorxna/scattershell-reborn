[{"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\store.js":"1","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\game\\gameSlice.js":"2","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\world.js":"3","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\cell\\Cell.js":"4","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\event\\EventLog.js":"5","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\index.js":"6","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\entity\\Entity.js":"7","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\generateIsland.js":"8","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\gameMiddleware.js":"9","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\event\\eventSlice.js":"10","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\IslandMap.js":"11","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\entity\\entitySlice.js":"12","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\IslandBuilder.js":"13","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\game\\ShellscatterGame.js":"14","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\cell-group\\cellGroupSlice.js":"15","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\game\\Tree.js":"16","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\map\\Map.js":"17","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\islandSlice.js":"18","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Resources.js":"19","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Game.js":"20","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\ActionValidation.js":"21","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Actions.js":"22","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\serviceWorker.js":"23","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Locations.js":"24","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\IslandProperties.js":"25","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\App.js":"26","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\properties.js":"27","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\cell\\cellSlice.js":"28","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\polyomino\\polyominoSlice.js":"29","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Theme.js":"30","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\index.js":"31","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\App.js":"32","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\serviceWorker.js":"33","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\app\\store.js":"34","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\islandSlice.js":"35","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\cell\\cellSlice.js":"36","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\world.js":"37","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\properties.js":"38","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\generateIsland.js":"39","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\app\\Resources.js":"40","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\game\\IslandGame.js":"41","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\IslandMap.js":"42","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\cell\\Cell.js":"43","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\notes\\Notes.js":"44","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\notes\\useNotes.js":"45"},{"size":737,"mtime":1608167532865,"results":"46","hashOfConfig":"47"},{"size":1046,"mtime":1608250963047,"results":"48","hashOfConfig":"47"},{"size":245,"mtime":1608016991595,"results":"49","hashOfConfig":"47"},{"size":1889,"mtime":1608169918699,"results":"50","hashOfConfig":"51"},{"size":2334,"mtime":1622107584833,"results":"52","hashOfConfig":"47"},{"size":676,"mtime":1622094547405,"results":"53","hashOfConfig":"47"},{"size":1426,"mtime":1609055671339,"results":"54","hashOfConfig":"51"},{"size":7329,"mtime":1621744091998,"results":"55","hashOfConfig":"47"},{"size":1543,"mtime":1621997939262,"results":"56","hashOfConfig":"47"},{"size":3120,"mtime":1621745158960,"results":"57","hashOfConfig":"47"},{"size":3935,"mtime":1608170009682,"results":"58","hashOfConfig":"51"},{"size":932,"mtime":1621936619503,"results":"59","hashOfConfig":"47"},{"size":4553,"mtime":1621937127092,"results":"60","hashOfConfig":"51"},{"size":2207,"mtime":1622106314115,"results":"61","hashOfConfig":"47"},{"size":903,"mtime":1608106660583,"results":"62","hashOfConfig":"51"},{"size":896,"mtime":1621937503523,"results":"63","hashOfConfig":"47"},{"size":4148,"mtime":1622077012244,"results":"64","hashOfConfig":"47"},{"size":1320,"mtime":1608027436882,"results":"65","hashOfConfig":"47"},{"size":3120,"mtime":1621998402537,"results":"66","hashOfConfig":"47"},{"size":3557,"mtime":1621998386365,"results":"67","hashOfConfig":"47"},{"size":6837,"mtime":1620892665902,"results":"68","hashOfConfig":"51"},{"size":5515,"mtime":1622026146622,"results":"69","hashOfConfig":"47"},{"size":5141,"mtime":1606205142047,"results":"70","hashOfConfig":"47"},{"size":4533,"mtime":1622071996487,"results":"71","hashOfConfig":"47"},{"size":1519,"mtime":1621998427846,"results":"72","hashOfConfig":"47"},{"size":524,"mtime":1622076475471,"results":"73","hashOfConfig":"47"},{"size":631,"mtime":1606554150967,"results":"74","hashOfConfig":"47"},{"size":9247,"mtime":1608104249781,"results":"75","hashOfConfig":"47"},{"size":1308,"mtime":1608085901366,"results":"76","hashOfConfig":"47"},{"size":198,"mtime":1621998478541,"results":"77","hashOfConfig":"47"},{"size":676,"mtime":1627178740761,"results":"78","hashOfConfig":"79"},{"size":1363,"mtime":1650958252523,"results":"80","hashOfConfig":"79"},{"size":5141,"mtime":1627178740586,"results":"81","hashOfConfig":"79"},{"size":276,"mtime":1650869135991,"results":"82","hashOfConfig":"79"},{"size":809,"mtime":1650869105652,"results":"83","hashOfConfig":"79"},{"size":8840,"mtime":1650869131555,"results":"84","hashOfConfig":"79"},{"size":245,"mtime":1627178741125,"results":"85","hashOfConfig":"79"},{"size":695,"mtime":1650882678633,"results":"86","hashOfConfig":"79"},{"size":7593,"mtime":1650882740134,"results":"87","hashOfConfig":"79"},{"size":3122,"mtime":1650888541077,"results":"88","hashOfConfig":"79"},{"size":374,"mtime":1650869123148,"results":"89","hashOfConfig":"79"},{"size":3283,"mtime":1650958161865,"results":"90","hashOfConfig":"79"},{"size":2491,"mtime":1650953870652,"results":"91","hashOfConfig":"79"},{"size":1574,"mtime":1650956972505,"results":"92","hashOfConfig":"79"},{"size":2930,"mtime":1650882072518,"results":"93","hashOfConfig":"79"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},"3vjv1s",{"filePath":"97","messages":"98","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"96"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"96"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"xk6vq3",{"filePath":"105","messages":"106","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107"},{"filePath":"108","messages":"109","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"110","messages":"111","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"112","usedDeprecatedRules":"113"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116","usedDeprecatedRules":"96"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"119","usedDeprecatedRules":"96"},{"filePath":"120","messages":"121","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"122","messages":"123","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"124","messages":"125","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"126","usedDeprecatedRules":"96"},{"filePath":"127","messages":"128","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"129","messages":"130","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"131","usedDeprecatedRules":"96"},{"filePath":"132","messages":"133","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"134","messages":"135","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"136","messages":"137","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"138","usedDeprecatedRules":"96"},{"filePath":"139","messages":"140","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"141","usedDeprecatedRules":"96"},{"filePath":"142","messages":"143","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"144","messages":"145","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"146","messages":"147","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"148"},{"filePath":"149","messages":"150","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"151","usedDeprecatedRules":"96"},{"filePath":"152","messages":"153","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"154","messages":"155","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"156","messages":"157","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"158","messages":"159","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"160","messages":"161","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"162","messages":"163","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"164","usedDeprecatedRules":"96"},{"filePath":"165","messages":"166","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"167","messages":"168","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"96"},{"filePath":"169","messages":"170","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"171"},"o0klal",{"filePath":"172","messages":"173","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"174","messages":"175","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"171"},{"filePath":"176","messages":"177","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"171"},{"filePath":"178","messages":"179","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"180","usedDeprecatedRules":"171"},{"filePath":"181","messages":"182","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"183","usedDeprecatedRules":"171"},{"filePath":"184","messages":"185","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"171"},{"filePath":"186","messages":"187","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"171"},{"filePath":"188","messages":"189","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"190","usedDeprecatedRules":"171"},{"filePath":"191","messages":"192","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"171"},{"filePath":"193","messages":"194","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"195","usedDeprecatedRules":"171"},{"filePath":"196","messages":"197","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"198","messages":"199","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"200","usedDeprecatedRules":"171"},{"filePath":"201","messages":"202","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"171"},{"filePath":"203","messages":"204","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"205","usedDeprecatedRules":"171"},"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\store.js",[],["206","207"],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\game\\gameSlice.js",["208","209"],"import { createSlice } from '@reduxjs/toolkit'\n\nexport const gameSlice = createSlice({\n  name: 'game',\n  initialState: {\n    ticks: 0,\n    year: 0,\n    month: 1,\n    day: 0,\n    log: [],\n    paused: false\n  },\n  reducers: {\n    tick: state => {\n      const { ticks, year, month, day, paused } = state\n      if (!state.paused) {\n        if (ticks % 10 === 0) state.day += 1\n        if (day === 31) {\n          state.month += 1\n          state.day = 1\n        }\n        if (month === 13) {\n          state.year += 1\n          state.month = 1\n        }\n        state.ticks = ticks + 1\n      }\n    },\n    appendLog: (state, action) => {\n      state.log.push(action.payload)\n    },\n    togglePause: (state, action) => {\n      state.paused = !state.paused\n    }\n  }\n})\n\nexport const { tick, appendLog, togglePause } = gameSlice.actions\n\nexport const appendLogAsync = thing => dispatch => {\n  dispatch(appendLog(thing))\n}\n\nexport const selectLog = state => state.game.log\n\nexport const selectGame = state => state.game\n\nexport default gameSlice.reducer\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\world.js",["210"],"export default {\n  harvfn: {\n    id: 'harvfn',\n    name: 'Harvfn',\n    size: 12,\n    starting: true\n  },\n  orthsar: {\n    id: 'orthsar',\n    name: 'Orthsar',\n    size: 2,\n  },\n  ngeled: {\n    id: 'ngeled',\n    name: 'Ngeled',\n    size: 3,\n  }\n}\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\cell\\Cell.js",["211","212","213","214","215","216","217","218"],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\event\\EventLog.js",["219"],"import React, { useEffect } from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\nimport {\n  selectEvent,\n  selectEventIds,\n  selectOngoingEventIds,\n  createEvent,\n  RecurringTypes\n} from '../event/eventSlice'\nimport { Button, Segment } from 'semantic-ui-react'\nimport { selectGame } from '../game/gameSlice'\nimport { EntityTypes, spawn } from '../entity/entitySlice'\nimport { SemanticToastContainer, toast } from 'react-semantic-toasts';\nimport 'react-semantic-toasts/styles/react-semantic-alert.css';\n\nfunction Event (props) {\n  const { id, ongoing } = props\n  const event = useSelector(selectEvent(id))\n  const { followup } = event\n  const { ticks } = useSelector(selectGame)\n\n  const ongoingText = ongoing()\n    ? `(ongoing... ${followup.dueTicks - ticks} ticks to go)`\n    : ''\n\n  useEffect(() => {\n    toast({\n      title: id,\n      description: `${JSON.stringify(event)} ${ongoingText}`,\n      animation: 'fade up'\n    })\n  }, [])\n\n  return (\n    <li>\n      {JSON.stringify(event)} {ongoingText}\n    </li>\n  )\n}\n\nexport function EventLog () {\n  const dispatch = useDispatch()\n  const eventIds = useSelector(selectEventIds)\n  const ongoingEventIds = useSelector(selectOngoingEventIds)\n  const game = useSelector(selectGame)\n\n  const createFollowupClicked = () => {\n    const cellId = 'harvfn:3:3'\n    const entityType = EntityTypes.person\n    dispatch(\n      createEvent({\n        followup: {\n          action: spawn({ cellId, entityType }),\n          dueTicks: game.ticks + 15\n        }\n      })\n    )\n  }\n\n  const createRecurringClicked = () => {\n    const cellId = 'harvfn:4:2'\n    const entityType = EntityTypes.person\n    dispatch(\n      createEvent({\n        followup: {\n          action: spawn({ cellId, entityType }),\n          dueTicks: game.ticks + 20,\n          recurringType: RecurringTypes.Randomly\n        }\n      })\n    )\n  }\n\n  return <>\n  <SemanticToastContainer />\n    <Segment>\n      <Button onClick={() => createFollowupClicked()}>\n        create event with followup action\n      </Button>\n\n      <Button onClick={() => createRecurringClicked()}>\n        create recurring event\n      </Button>\n\n      {eventIds.map(eventId => (\n        <Event\n          key={eventId}\n          id={eventId}\n          ongoing={() => ongoingEventIds.includes(eventId)}\n        />\n      ))}\n    </Segment>\n  </>\n}\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\index.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\entity\\Entity.js",["220","221","222","223","224"],"import React, { useState, useEffect } from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\nimport { spawn, EntityTypes } from './entitySlice'\nimport { Card, Row, Col, Button } from 'antd'\nimport Peep from 'react-peeps'\n\nconst { Meta } = Card\n\nconst styles = {\n\tpeepStyle: {\n\t\twidth: 300,\n\t\theight: 300,\n\t\tjustifyContent: 'center',\n\t\talignSelf: 'center'\n\t},\n\tcircleStyle: {\n        marginTop: '24px',\n\t\twidth: 270,\n\t\theight: 270,\n\t\talignSelf: 'center',\n\t\tborderRadius: 135,\n\t\toverflow: 'hidden',\n\t},\n}\n\nexport function Entity (props) {\n  const dispatch = useDispatch()\n\n  const spawnClicked = () => {\n    const cellId = 'harvfn:2:2'\n    const entityType = EntityTypes.person\n    dispatch(spawn({ cellId, entityType }))\n  }\n\n  const peep = (\n    <Peep\n      style={styles.peepStyle}\n      circleStyle={styles.circleStyle}\n      viewBox={{ x: '0', y: '0', width: '1050', height: '2400' }}\n      accessory='None'\n      body='OneLegUpBW'\n      face='Serious'\n      hair='BaldTop'\n      facialHair='GrayFull'\n      strokeColor='#222'\n      backgroundColor={{degree: 300, firstColor: '#61b15a', secondColor: '#fff76a'}}\n    />\n  )\n\n  return (\n    <>\n      <Button\n        onClick={() => {\n          spawnClicked()\n        }}\n      >\n        spawn entity\n      </Button>\n      <Card style={{ width: '400px' }} cover={peep}>\n        <Meta title='Person McPerson' description='foo bar baz' />\n      </Card>\n    </>\n  )\n}\n",["225","226"],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\generateIsland.js",["227","228","229","230","231"],"import { CellTypes } from './properties'\nimport * as Poisson from 'poisson-disk-sampling'\nimport {\n  ResourceTypes,\n  FoodPerResources,\n  WoodPerResources\n} from '../../app/Resources'\n\nconst GridPositions = (grid, size) => {\n  const u = pos => pos - size\n  const d = pos => pos + size\n  const l = pos => (pos % size === 0 ? undefined : pos - 1)\n  const r = pos => (pos % size === size - 1 ? undefined : pos + 1)\n\n  const up = pos => grid[u(pos)]\n  const down = pos => grid[d(pos)]\n  const left = pos => grid[l(pos)]\n  const right = pos => grid[r(pos)]\n\n  const upright = pos => grid[u(r(pos))]\n  const downleft = pos => grid[d(l(pos))]\n  const upleft = pos => grid[u(l(pos))]\n  const downright = pos => grid[d(r(pos))]\n\n  return { up, down, left, right, upright, downleft, upleft, downright }\n}\n\nconst randomChoice = arr => {\n  let index = Math.floor(Math.random() * arr.length)\n  return arr[index]\n}\n\nconst rand = (min, max) => Math.floor(Math.random() * (max - min + 1) + min)\n\nconst materialResources = Object.values(ResourceTypes).filter(x => {\n  return WoodPerResources[x] > 0\n})\nconst foodResources = Object.values(ResourceTypes).filter(\n  x => FoodPerResources[x] > 0\n)\nconst allResources = Object.values(ResourceTypes)\n\nconst buildCell = (cellType, neighbourCells) => {\n  let contains = []\n  if (cellType === CellTypes.Materials) {\n    contains = [\n      randomChoice(materialResources),\n      randomChoice(materialResources)\n    ]\n  } else if (cellType === CellTypes.Food) {\n    contains = [randomChoice(foodResources), randomChoice(foodResources)]\n  } else if (cellType === CellTypes.Desert) {\n    contains = [\n      randomChoice([\n        ResourceTypes.Succulents,\n        ResourceTypes.BushFood,\n        null,\n        null,\n        null\n      ])\n    ].filter(x => x != undefined)\n  } else if (cellType === CellTypes.Lagoon) {\n    contains = [\n      randomChoice([ResourceTypes.FreshWater, null]),\n      randomChoice([ResourceTypes.Fish, null])\n    ].filter(x => x != undefined)\n  } else {\n    contains = [randomChoice(allResources)]\n  }\n  return { cellType, contains }\n}\n\nexport const generateIsland = size => {\n  const baseCell = {\n    cellType: CellTypes.Undecided,\n    activated: false,\n    canActivate: false\n  }\n\n  const getPos = (x, y) => y * size + x\n\n  let grid = Array(size * size)\n    .fill({ ...baseCell })\n    .map((cell, pos) => ({ ...cell, pos }))\n\n  const {\n    up,\n    down,\n    left,\n    right,\n    upleft,\n    upright,\n    downleft,\n    downright\n  } = GridPositions(grid, size)\n\n  // add size/3 settlements\n\n  for (let i = 0; i < size / 4; i++) {\n    let x = rand(0, size - 1)\n    let y = rand(0, size - 1)\n    let cell = grid[getPos(x, y)]\n    grid[getPos(x, y)] = { ...cell, cellType: CellTypes.Settlement }\n  }\n\n  // add at least 1 food next to a settlement.\n  // find a settlement, pick a random direction that leads to another cell, place food.\n  const sPos = randomChoice(\n    grid.filter(cell => cell.cellType === CellTypes.Settlement)\n  ).pos\n  const essentialFoodCandidates = [\n    up(sPos),\n    down(sPos),\n    left(sPos),\n    right(sPos)\n  ].filter(x => x != undefined && x.cellType === CellTypes.Undecided)\n  const essentialFood = randomChoice(essentialFoodCandidates)\n\n  grid[essentialFood.pos] = {\n    ...essentialFood,\n    ...buildCell(CellTypes.Food)\n  }\n\n  const randomWalkUpdate = propertiesFn => {\n    let walk = [grid[sPos]]\n\n    let end = null\n    while (walk.length < size) {\n      let head = walk[walk.length - 1]\n      let candidates = [up, down, left, right]\n        .map(fn => fn(head.pos))\n        .filter(\n          x =>\n            x &&\n            (walk.length > 3\n              ? x.cellType === CellTypes.Undecided\n              : x.cellType !== CellTypes.Settlement &&\n                x.cellType !== CellTypes.Food) &&\n            walk.filter(w => w.pos === x.pos).length === 0\n        )\n      let pick = randomChoice(candidates)\n      if (pick) walk.push(pick)\n      else {\n        break\n      }\n    }\n    end = walk.pop()\n    grid[end.pos] = {\n      ...end,\n      ...propertiesFn([up, down, left, right].map(fn => fn(end.pos)))\n    }\n    return [...walk, end]\n  }\n\n  randomWalkUpdate(neighbours => buildCell(CellTypes.Materials, neighbours))\n\n  if (size > 5) {\n    randomWalkUpdate(neighbours => buildCell(CellTypes.Mountain, neighbours))\n  }\n\n  const desertRate = 1.5\n  const pDesert = new Poisson([size, size], size / desertRate)\n\n  pDesert\n    .fill()\n    .map(point => getPos(Math.round(point[0]), Math.round(point[1])))\n    .forEach(pos => {\n      if (grid[pos] && grid[pos].cellType === CellTypes.Undecided) {\n        // clump the desert cells together on von neumann neighbourhood\n        // alternate direction of pill shapes\n        let neighbours = [\n          up,\n          down,\n          left,\n          right,\n          ...randomChoice([\n            [upright, downleft],\n            [downright, upleft]\n          ])\n        ].map(fn => fn(pos))\n\n        let desertCount = 0\n        for (let neighbour of neighbours) {\n          if (neighbour && neighbour.cellType === CellTypes.Undecided) {\n            grid[neighbour.pos] = {\n              ...grid[neighbour.pos],\n              ...buildCell(CellTypes.Desert)\n            }\n            desertCount += 1\n          }\n        }\n        // oasis :)\n        grid[pos] = {\n          ...grid[pos],\n          ...buildCell(desertCount === 6 ? CellTypes.Lagoon : CellTypes.Desert)\n        }\n      }\n    })\n\n  const pMountains = new Poisson([size, size], size / 4)\n\n  pMountains\n    .fill()\n    .map(point => getPos(Math.round(point[0]), Math.round(point[1])))\n    .forEach(pos => {\n      let noOtherMountains =\n        [left, right, up, down]\n          .map(fn => fn(pos))\n          .filter(nn => nn == undefined || nn.cellType === CellTypes.Mountain)\n          .length === 0\n\n      if (\n        grid[pos] &&\n        grid[pos].cellType === CellTypes.Undecided &&\n        noOtherMountains\n      ) {\n        grid[pos] = { ...grid[pos], ...buildCell(CellTypes.Mountain, []) } // todo\n        let neighbours = [upright(pos), downleft(pos)]\n        for (let neighbour of neighbours) {\n          if (neighbour && neighbour.cellType === CellTypes.Undecided) {\n            let others = [up, down, left, right].map(fn => fn(neighbour.pos))\n            let noOtherMountains =\n              others.filter(\n                nn => nn == undefined || nn.cellType === CellTypes.Mountain\n              ).length === 0\n            if (noOtherMountains) {\n              grid[neighbour.pos] = {\n                ...grid[neighbour.pos],\n                ...buildCell(CellTypes.Mountain, [])\n              } // todo\n            }\n          }\n        }\n      }\n    })\n\n  const pGrass = new Poisson([size, size], size / 8)\n\n  pGrass\n    .fill()\n    .map(point => getPos(Math.round(point[0]), Math.round(point[1])))\n    .forEach(pos => {\n      if (grid[pos] && grid[pos].cellType === CellTypes.Undecided) {\n        grid[pos] = { ...grid[pos], ...buildCell(CellTypes.Grass) }\n      }\n    })\n\n  grid.forEach(cell => {\n    if (cell.cellType === CellTypes.Undecided) {\n      grid[cell.pos] = {\n        ...cell,\n        ...buildCell(\n          randomChoice([\n            CellTypes.Food,\n            CellTypes.Materials,\n            CellTypes.Lagoon\n            // CellTypes.Undecided\n          ])\n        )\n      }\n    }\n  })\n\n  return grid\n}\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\gameMiddleware.js",["232","233"],"import { appendLogAsync } from '../features/game/gameSlice'\nimport { tick } from '../features/game/gameSlice'\n\nconst stripFromLog = ['log', 'createsEvent']\nconst TICK_INTERVAL = 1000\n\nconst gameMiddleware = store => next => action => {\n  /*const log = async ticks => {\n    // const state = store.getState() //state at the time of logging\n    const loggedStuff = Object.fromEntries(\n      Object.entries(action.payload).filter(\n        ([key, val]) => stripFromLog.indexOf(key) === -1\n      )\n    ) // don't log the 'log' field\n    await store.dispatch(appendLogAsync({ ...loggedStuff, when: ticks }))\n  }*/\n\n  const state = store.getState()\n\n  if (action.type === 'game/tick') {\n    // for any actions with a followup action, dispatch the followup when due\n    state.event.ongoingIds.forEach(eventId => {\n      const event = state.event.byId[eventId]\n      const { followup } = event\n      if (state.game.ticks === followup.dueTicks) {\n        store.dispatch({\n          ...followup.action,\n          followupForEventId: eventId\n        })\n      }\n    })\n  }\n\n  const { paused } = state.game\n\n  // set up next tick if not currently paused, or currently paused and becoming unpaused\n  if (\n    (!paused && action.type === 'game/tick') ||\n    (paused && action.type === 'game/togglePause')\n  ) {\n    setTimeout(() => {\n      store.dispatch(tick())\n    }, TICK_INTERVAL)\n  }\n\n  /*if (action.payload && action.payload.log) {\n    // log(state.game.ticks)\n  }*/\n\n  return next({ ...action, when: state.game.ticks })\n}\n\nexport default gameMiddleware\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\event\\eventSlice.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\IslandMap.js",["234","235","236","237","238","239","240"],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\entity\\entitySlice.js",["241"],"import { createSlice } from '@reduxjs/toolkit'\nimport world from '../island/world'\nimport { english as generateId } from 'nanoid-generate'\n\nexport const EntityTypes = {\n  person: 'person',\n  thing: 'thing'\n}\n\nexport const entitySlice = createSlice({\n  name: 'entity',\n  initialState: {\n    byId: {}\n  },\n  reducers: {\n    spawn: {\n      reducer: (state, action) => {\n        const { cellId, entityType, id } = action.payload\n        const birthplaceCellId = cellId\n        const traits = {}\n        state.byId[id] = {\n          id,\n          entityType,\n          cellId,\n          birthplaceCellId,\n          traits\n        }\n      },\n      prepare: properties => {\n        const id = generateId(10)\n        const log = true\n        const createsEvent = true\n        return { payload: { id, log, createsEvent, ...properties } }\n      }\n    }\n  }\n})\n\nexport const { spawn } = entitySlice.actions\n\nexport default entitySlice.reducer\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\IslandBuilder.js",["242","243","244","245","246","247","248"],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\game\\ShellscatterGame.js",["249","250","251","252"],"import React, { useEffect } from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nimport { generateGrid } from '../cell/cellSlice'\nimport { EventLog } from '../event/EventLog'\nimport { tick, selectGame, togglePause } from './gameSlice'\nimport { AncestryTree } from './Tree'\nimport ScattershellMap from '../map/Map'\nimport { ScattershellLocations } from '../../app/Locations'\nimport { Label, Menu, Button, Container, Image, Segment } from 'semantic-ui-react'\n\nfunction GameHeader (props) {\n  const dispatch = useDispatch()\n  const game = useSelector(selectGame)\n  const { paused, ticks } = game\n  const tags = [paused && <Label color='blue'>paused</Label>]\n\n  return (\n    <Menu fixed='top' color={'blue'} inverted>\n      <Container>\n        <Menu.Item as='a' header >\n          <Image\n            size='mini'\n            src='https://avatars1.githubusercontent.com/u/26913568?s=460&v=4'\n            style={{ marginRight: '1.5em' }}\n          />\n          <span className='header-text'>Scattershell</span>\n        </Menu.Item>\n        <Menu.Item as='a' color='yellow'>Map</Menu.Item>\n        <Menu.Item as='a' color='yellow'>Ancestry</Menu.Item>\n        <Menu.Item as='a' color='yellow'>Events</Menu.Item>\n        <Menu.Menu position='right'>\n          <Menu.Item>\n            <Button color='yellow'\n              basic inverted\n              onClick={() => {\n                dispatch(togglePause())\n              }}\n            >\n              {paused ? 'resume' : 'pause'}\n            </Button>\n          </Menu.Item>\n          <Menu.Item header>\n          {ticks}\n          </Menu.Item>\n        </Menu.Menu>\n      </Container>\n    </Menu>\n  )\n}\n\nexport function ShellscatterGame () {\n  const dispatch = useDispatch()\n\n  useEffect(() => {\n    /* start the game loop */\n    dispatch(tick())\n    //dispatch(generateGrid({ islandId: 'harvfn' }))\n  }, [])\n\n  const discoveredLocations = ScattershellLocations\n\n  return (\n    <div className={'app'}>\n      <GameHeader />\n      <Container style={{ marginTop: '7em' }}>\n      <ScattershellMap islands={discoveredLocations} />\n      <AncestryTree />\n      <EventLog />\n</Container>\n      {/*<IslandBuilder islandId={'harvfn'} />*/}\n    </div>\n  )\n}\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\cell-group\\cellGroupSlice.js",["253"],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\game\\Tree.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\map\\Map.js",["254","255","256","257"],"import React, { useRef, useEffect } from 'react'\r\nimport * as SVG from 'svg.js'\r\nimport rough from 'roughjs/bin/rough'\r\nimport { Colors } from '../../app/Theme'\r\nimport { IslandTypes } from '../../app/IslandProperties'\r\nimport { islandsDetails } from '../../app/Game'\r\n\r\nconst styles = {\r\n  svg: {\r\n    width: '620px',\r\n    height: '580px',\r\n    padding: '2em',\r\n    backgroundColor: Colors.Deep,\r\n  }\r\n}\r\n\r\nconst defaultScattershellMapProps = {\r\n  currentIsland: 'Morrigan',\r\n  paths: [],\r\n\r\n  baseMarkerOptions: {\r\n    //stroke: Colors.Outline,\r\n    fill: Colors.Green, //Colors.Outline,\r\n    fillStyle: 'solid',\r\n    hachureAngle: 65,\r\n    roughness: 1,\r\n    stroke: 0,\r\n    fillWeight: 2,\r\n    bowing: 2\r\n  },\r\n\r\n  activePlaceOptions: {\r\n    fill: Colors.Green,\r\n    stroke: Colors.Light,\r\n    strokeWidth: 5\r\n  },\r\n\r\n  inactivePlaceOptions: {},\r\n  pathOptions: {},\r\n\r\n  sizes: {\r\n    [IslandTypes.Rocks]: 5,\r\n    [IslandTypes.Guano]: 10,\r\n    [IslandTypes.Small]: 15,\r\n    [IslandTypes.Medium]: 20,\r\n    [IslandTypes.Large]: 35\r\n  }\r\n}\r\n\r\nfunction ScattershellMap (props) {\r\n  const {\r\n    islands,\r\n    paths,\r\n    baseMarkerOptions,\r\n    activePlaceOptions,\r\n    inactivePlaceOptions,\r\n    lineOptions,\r\n    sizes,\r\n    currentIsland // string\r\n  } = {\r\n    ...defaultScattershellMapProps,\r\n    ...props\r\n  }\r\n\r\n  const xOffset = -40,\r\n    yOffset = 0\r\n\r\n  const opts = baseMarkerOptions\r\n\r\n  const righties = ['The Pip', 'Elder', 'Father', 'Shell Cove', 'Younger']\r\n\r\n  const svgRef = useRef(null)\r\n\r\n  function renderMap (svg) {\r\n    const rc = rough.svg(svg)\r\n    const draw = SVG(svg) //svg.js draw\r\n\r\n    /* draw.click(event => {\r\n      let x = event.clientX - draw.parent.offsetLeft,\r\n        y = event.clientY - draw.parent.offsetTop\r\n      \r\n        console.log(x,y)\r\n    })*/\r\n\r\n    const placeMarker = ({ name, x, y, type, markerOptions }) => {\r\n      let circleOpts = {\r\n        ...opts,\r\n        ...(name === currentIsland ? activePlaceOptions : inactivePlaceOptions),\r\n        ...markerOptions\r\n      }\r\n      return rc.circle(\r\n        x * 5 + xOffset,\r\n        y * 5 + yOffset,\r\n        sizes[type],\r\n        circleOpts\r\n      )\r\n    }\r\n    const pathMarker = (place1, place2) =>\r\n      rc.line(place1.x, place1.y, place2.x, place2.y, {\r\n        ...opts,\r\n        ...lineOptions,\r\n        stroke: Colors.Light\r\n      })\r\n\r\n    const labelMarker = place => {\r\n      draw\r\n        .link('javascript:;')\r\n        .text(place.name)\r\n        .fill(Colors.Light)\r\n        .x(\r\n          place.x * 5 +\r\n            xOffset +\r\n            (righties.indexOf(place.name) !== -1 ? Math.min(50, sizes[place.type] * 4) : 0)\r\n        )\r\n        .y(\r\n          place.y * 5 +\r\n            yOffset +\r\n            (righties.indexOf(place.name) !== -1\r\n              ? -20\r\n              : sizes[place.type] / 2 - 10)\r\n        ) //(place.isBig ? 30 : 20))\r\n        .font({\r\n          family: 'ReenieBeanie-Regular',\r\n          size: 24,\r\n          anchor: 'middle'\r\n        })\r\n        .on('click', () => {\r\n          props.setCurrentIsland(place.name)\r\n        })\r\n    }\r\n\r\n    // draw the labels\r\n   // debugger;\r\n    Object.values(islands).forEach(place => {\r\n   //   if (place.isDiscovered) {\r\n        let marker = placeMarker(place)\r\n        svg.appendChild(marker)\r\n        labelMarker(place)\r\n     // }\r\n    })\r\n\r\n    // draw the paths\r\n    paths.forEach(([fromId, toId]) => {\r\n      let marker = pathMarker(islands[fromId], islands[toId])\r\n      svg.appendChild(marker)\r\n    })\r\n  }\r\n\r\n  // Render initial\r\n  useEffect(() => {\r\n    let svg = svgRef.current\r\n    renderMap(svg)\r\n  }, [svgRef.current])\r\n\r\n  const reRender = () => {\r\n    let svg = svgRef.current\r\n    if (svg) {\r\n      while (svg.lastChild) {\r\n        svg.removeChild(svg.lastChild)\r\n      }\r\n      renderMap(svg)\r\n    }\r\n  }\r\n\r\n  /*// Re-render when islands are discovered or current island changes\r\n  const discoveries = Object.entries(islands).map(\r\n    ([name, place]) => place.isDiscovered\r\n  )\r\n\r\n  useEffect(reRender, discoveries)\r\n  useEffect(reRender, [currentIsland])\r\n*/\r\n\r\n  return <svg ref={svgRef} style={styles.svg} />\r\n}\r\n\r\nexport default ScattershellMap\r\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\islandSlice.js",["258"],"import { createSlice, createSelector } from '@reduxjs/toolkit'\nimport world from './world'\n\nconst initialIslandById = Object.fromEntries(\n  Object.entries(world).map(([islandId, island]) => {\n    return [\n      islandId,\n      {\n        ...island,\n        discovered: island.starting,\n        confirmed: false\n      }\n    ]\n  })\n)\n\nexport const islandSlice = createSlice({\n  name: 'island',\n  initialState: {\n    byId: initialIslandById\n  },\n  reducers: {\n    confirmIsland: (state, action) => {\n      /* would be better if this is only possible when all cells for\n       an island have been activated */\n      const { islandId } = action.payload\n      state.byId[islandId].confirmed = true\n    }\n  }\n})\n\nexport default islandSlice.reducer\n\nexport const { confirmIsland } = islandSlice.actions\n\nexport const selectStartingIsland = state =>\n  state.island.byId.filter(x => x.starting)[0]\n\nexport const selectDiscoveredIslands = state =>\n  state.island.byId.filter(x => x.discovered)\n\nexport const allCellsActivated = islandId => state =>\n  state.island.byId[islandId].remainingActivations === 0\n\nexport const noCellsActivated = islandId => state =>\n  state.island.byId[islandId].remainingActivations ===\n  state.island.byId[islandId].size\n\nexport const selectIslandById = islandId => state => state.island.byId[islandId]\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Resources.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Game.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\ActionValidation.js",["259"],"import { IslandMaxPopulations } from './IslandProperties'\r\nimport {\r\n  MaxDwellings,\r\n  MaxGardens,\r\n  SettlementRequiredPeople,\r\n  NumVoyagers\r\n} from './Game'\r\nimport { ActionCosts, ActionTypes } from './Actions'\r\nimport { IsGardenFood } from './Resources'\r\nimport { ScattershellLocations } from './Locations'\r\n\r\nfunction checkCosts(player, actionCosts) {\r\n  const { food, wood, energy } = player\r\n\r\n  const foodCost = actionCosts['foodΔ']\r\n  const woodCost = actionCosts['woodΔ']\r\n  const energyCost = actionCosts['energyΔ']\r\n\r\n  const foodDiff = food + foodCost\r\n  const woodDiff = wood + woodCost\r\n  const energyDiff = energy + energyCost\r\n\r\n  return [\r\n    foodCost == null\r\n      ? null\r\n      : foodDiff >= 0\r\n      ? { met: true, text: `${-foodCost} food ✔` }\r\n      : { met: false, text: `not enough food (need ${-foodDiff})` },\r\n    woodCost == null\r\n      ? null\r\n      : woodDiff >= 0\r\n      ? { met: true, text: `${-woodCost} materials ✔` }\r\n      : { met: false, text: `not enough materials (need ${-woodDiff})` },\r\n    energyCost == null\r\n      ? null\r\n      : energyDiff >= 0\r\n      ? { met: true, text: `${-energyCost} energy ✔` }\r\n      : { met: false, text: `not enough energy (need ${-energyDiff})` }\r\n  ].filter(x => x != null)\r\n}\r\n\r\nfunction validateAction(actionType, game, islandId, populationRequired) {\r\n  const { player, islands } = game\r\n  const island = islands[islandId]\r\n  const { population } = island\r\n\r\n  const actionCosts = ActionCosts[actionType]\r\n\r\n  const populationMet =\r\n    populationRequired == null\r\n      ? null\r\n      : population >= populationRequired\r\n      ? { met: true, text: `${populationRequired} people ✔` }\r\n      : {\r\n          met: false,\r\n          text: `not enough people (need ${populationRequired -\r\n            population} more)`\r\n        }\r\n\r\n  return [...checkCosts(player, actionCosts), populationMet].filter(\r\n    x => x != null\r\n  )\r\n}\r\n\r\nconst validateLaunch = (game, islandId, task) => {\r\n  const { progressItems, islands } = game\r\n  const { actionType } = task\r\n\r\n  const isAlreadyGoing =\r\n    progressItems.filter(otherItem => {\r\n      const isSameActionType = actionType === otherItem.actionType\r\n      const isSameIsland = islandId === otherItem.islandName\r\n      const isGoingToSameDestination =\r\n        isSameActionType && task.toName === otherItem.task.toName\r\n      const justStarted = otherItem.progress === 0\r\n      return isSameIsland && isGoingToSameDestination && !justStarted\r\n    }).length > 0\r\n\r\n  return [\r\n    ...validateAction(actionType, game, islandId, NumVoyagers[actionType]),\r\n    {\r\n      met: !isAlreadyGoing,\r\n      text: isAlreadyGoing ? `already voyaging` : ''\r\n    }\r\n  ]\r\n}\r\n\r\nconst validateAddPerson = (game, islandId) => {\r\n  const { islands, progressItems } = game\r\n  const actionType = ActionTypes.AddPerson\r\n  const island = islands[islandId]\r\n  const { population, bonusPopulation, hasSettlement } = island\r\n  const islandLocation = ScattershellLocations[islandId]\r\n\r\n  const maxPopulation = IslandMaxPopulations[islandLocation.type]\r\n  const totalPopulationLimit = bonusPopulation + maxPopulation\r\n\r\n  // include population in progress\r\n  const queuedPopulation = progressItems.filter(progressItem => {\r\n    return (\r\n      progressItem.actionType === actionType &&\r\n      progressItem.islandName === islandId\r\n    )\r\n  }).length // assumes 1 person per action\r\n\r\n  const maxPopulationReached =\r\n    population + queuedPopulation === totalPopulationLimit\r\n\r\n  return [\r\n    ...validateAction(actionType, game, islandId),\r\n    {\r\n      met: !maxPopulationReached,\r\n      text: maxPopulationReached ? 'max population reached' : ''\r\n    },\r\n    {\r\n      met: hasSettlement,\r\n      text: !hasSettlement ? 'no settlement' : ''\r\n    }\r\n  ]\r\n}\r\n\r\nconst validateAddDwelling = (game, islandId) => {\r\n  const actionType = ActionTypes.AddDwelling\r\n  const { islands, progressItems } = game\r\n  const island = islands[islandId]\r\n  const { numDwellings, hasSettlement } = island\r\n  const inProgress = progressItems.filter(\r\n    progressItem =>\r\n      progressItem.actionType === actionType &&\r\n      progressItem.islandName === islandId\r\n  ).length // assumes 1 dwelling per action\r\n\r\n  const isMaxDwellings = numDwellings + inProgress === MaxDwellings\r\n  return [\r\n    ...validateAction(ActionTypes.AddDwelling, game, islandId),\r\n    {\r\n      met: !isMaxDwellings,\r\n      text: isMaxDwellings ? 'max dwellings built here' : ''\r\n    },\r\n    {\r\n      met: hasSettlement,\r\n      text: !hasSettlement ? 'no settlement' : ''\r\n    }\r\n  ]\r\n}\r\n\r\nconst validateAddSettlement = (game, islandId) => {\r\n  const { progressItems } = game\r\n  const actionType = ActionTypes.AddSettlement\r\n  const inProgress =\r\n    progressItems.filter(\r\n      progressItem =>\r\n        progressItem.actionType === actionType &&\r\n        progressItem.islandName === islandId\r\n    ).length === 1\r\n\r\n  return [\r\n    ...validateAction(\r\n      ActionTypes.AddSettlement,\r\n      game,\r\n      islandId,\r\n      SettlementRequiredPeople\r\n    ),\r\n    {\r\n      met: !inProgress,\r\n      text: inProgress ? 'settlement in progress' : ''\r\n    }\r\n  ]\r\n}\r\n\r\nconst validateAddTemple = (game, islandId) => {\r\n  const { progressItems } = game\r\n  const actionType = ActionTypes.AddTemple\r\n  const inProgress =\r\n    progressItems.filter(\r\n      progressItem =>\r\n        progressItem.actionType === actionType &&\r\n        progressItem.islandName === islandId\r\n    ).length === 1\r\n\r\n  return [\r\n    ...validateAction(ActionTypes.AddTemple, game, islandId),\r\n    {\r\n      met: !inProgress,\r\n      text: inProgress ? 'temple in progress' : ''\r\n    }\r\n  ]\r\n}\r\n\r\n// todo requires settlement\r\nconst validateAddGarden = (game, islandId) => {\r\n  const { islands, progressItems } = game\r\n  const island = islands[islandId]\r\n  const { resources, numGardens } = island\r\n\r\n  // include any gardens in progress\r\n  const actionType = ActionTypes.AddGarden\r\n  const inProgressGardens = progressItems.filter(\r\n    progressItem =>\r\n      progressItem.actionType === actionType &&\r\n      progressItem.islandName === islandId\r\n  ).length\r\n\r\n  const isMaxGardens = numGardens + inProgressGardens === MaxGardens\r\n\r\n  // make sure the island has at least one horticultural resource\r\n  const hasHorticulturalResources =\r\n    resources.filter(res => IsGardenFood[res]).length > 0\r\n\r\n  return [\r\n    ...validateAction(ActionTypes.AddGarden, game, islandId, 5),\r\n    {\r\n      met: !isMaxGardens,\r\n      text: isMaxGardens ? 'max gardens planted here' : ''\r\n    },\r\n    {\r\n      met: hasHorticulturalResources,\r\n      text: hasHorticulturalResources\r\n        ? 'island has horticultural resources ✔'\r\n        : 'no horticultural resources here'\r\n    }\r\n  ]\r\n}\r\n\r\nexport {\r\n  validateAddDwelling,\r\n  validateAddGarden,\r\n  validateAddPerson,\r\n  validateAddSettlement,\r\n  validateAddTemple,\r\n  validateLaunch\r\n}\r\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Actions.js",["260","261","262","263"],"import { ScattershellLocations } from './Locations'\r\nimport { IslandTypes } from './IslandProperties'\r\n\r\nconst ActionTypes = {\r\n  LaunchOutrigger: 'outrigger voyage',\r\n  LaunchFleet: 'fleet voyage',\r\n  AddPerson: 'new child',\r\n  AddDwelling: 'build dwelling',\r\n  AddSettlement: 'raise settlement',\r\n  AddGarden: 'plant garden',\r\n  AddTemple: 'build temple',\r\n  SpendEnergy: 'accept offerings'\r\n}\r\n\r\nconst ActionCosts = {\r\n  [ActionTypes.LaunchOutrigger]: {\r\n    woodΔ: -25,\r\n    foodΔ: -50,\r\n    energyΔ: -10\r\n  },\r\n  [ActionTypes.LaunchFleet]: {\r\n    woodΔ: -100,\r\n    foodΔ: -200,\r\n    energyΔ: -20\r\n  },\r\n  [ActionTypes.AddPerson]: {\r\n    foodΔ: -50,\r\n    energyΔ: -25\r\n  },\r\n  [ActionTypes.AddDwelling]: {\r\n    woodΔ: -100\r\n  },\r\n  [ActionTypes.AddSettlement]: {\r\n    woodΔ: -250\r\n  },\r\n  [ActionTypes.AddGarden]: {\r\n    woodΔ: -500\r\n  },\r\n  [ActionTypes.AddTemple]: {\r\n    woodΔ: -1000,\r\n    foodΔ: -1000,\r\n    energyΔ: -100\r\n  }\r\n}\r\n\r\nconst finishVoyage = actionInstance => {\r\n  const { islandName, actionType, task } = actionInstance\r\n  const { toName, destinationIsDiscovered } = task\r\n  const { numPeople } = Actions[actionType]\r\n  const to = ScattershellLocations[toName]\r\n  const isInhospitable = to.type === IslandTypes.Rocks\r\n\r\n  const successMsg = destinationIsDiscovered\r\n    ? `The voyage disembarked safely.`\r\n    : `A ${to.type} island was discovered!`\r\n\r\n  const rocksMsg = `An inhospitable outcrop of rocks was encountered. The ${numPeople} voyagers perished.`\r\n  const msg = `The voyage from ${islandName} arrived at ${toName}. ${\r\n    isInhospitable ? rocksMsg : successMsg\r\n  }`\r\n  return msg\r\n}\r\n\r\nconst getVoyageDuration = task => {\r\n  const { islandName, toName, isBeginning } = task\r\n  return isBeginning\r\n    ? 10\r\n    : ScattershellLocations[islandName].neighbourDistance[toName] * 10\r\n}\r\n\r\nconst getVoyageName = task => {\r\n  const {\r\n    actionType,\r\n    destinationIsDiscovered,\r\n    islandName,\r\n    toName,\r\n    isBeginning\r\n  } = task\r\n  return isBeginning\r\n    ? `Voyage to ${toName}`\r\n    : `Voyage from ${islandName} to ${\r\n        destinationIsDiscovered ? toName : 'an undiscovered land'\r\n      }`\r\n}\r\n\r\nconst Actions = {\r\n  [ActionTypes.SpendEnergy]: {\r\n    text: 'accept offerings',\r\n    /*    beginStateChange: State.spendEnergy,\r\n    endStateChange: () => {},\r\n    finishMessage: () => {},\r\n*/ emoji:\r\n      '⚡',\r\n    /*    validate: () => [{ met: true }],\r\n    getDuration: () => {},\r\n    getName: () => {},\r\n*/ hidden: true // don't show in progress\r\n  },\r\n  [ActionTypes.LaunchOutrigger]: {\r\n    text: 'launch outrigger',\r\n    /*    beginStateChange: State.launchVoyage,\r\n    endStateChange: State.arriveVoyage,\r\n    finishMessage: finishVoyage,\r\n*/ emoji:\r\n      '⛵',\r\n    cost: ActionCosts[ActionTypes.LaunchOutrigger]\r\n    /*    validate: validateLaunch,\r\n    getDuration: getVoyageDuration,\r\n    getName: getVoyageName, \r\n    numPeople: 2 */\r\n  },\r\n  [ActionTypes.LaunchFleet]: {\r\n    text: 'launch fleet',\r\n    /*    beginStateChange: State.launchVoyage,\r\n    endStateChange: State.arriveVoyage,\r\n    finishMessage: finishVoyage,\r\n */ emoji:\r\n      '⛵'\r\n    /*   cost: ActionCosts[ActionTypes.LaunchFleet],\r\n    validate: validateLaunch,\r\n    getDuration: getVoyageDuration,\r\n    getName: getVoyageName,\r\n    numPeople: 5\r\n  */\r\n  },\r\n  [ActionTypes.AddPerson]: {\r\n    text: 'spawn person',\r\n    /*    beginStateChange: State.beginAddPerson,\r\n    endStateChange: State.endAddPerson,\r\n*/ emoji:\r\n      '👶'\r\n    /*    finishMessage: ({ islandName }) => `a child was born in ${islandName}!`,\r\n    cost: ActionCosts[ActionTypes.AddPerson],\r\n    validate: validateAddPerson,\r\n    getDuration: () => 20,\r\n    getName: task => `person`\r\n  */\r\n  },\r\n  [ActionTypes.AddDwelling]: {\r\n    text: 'build dwelling',\r\n    emoji: '🏠'\r\n    /*   cost: ActionCosts[ActionTypes.AddDwelling],\r\n    beginStateChange: State.beginAddDwelling,\r\n    endStateChange: State.endAddDwelling,\r\n    finishMessage: ({ islandName }) => `a dwelling was built in ${islandName}!`,\r\n    // todo settlement required\r\n    validate: validateAddDwelling,\r\n    getDuration: () => 20,\r\n    getName: task => `dwelling`\r\n  */\r\n  },\r\n  [ActionTypes.AddSettlement]: {\r\n    // todo already has settlement\r\n    text: 'raise settlement',\r\n    emoji: '🏠'\r\n    /*  endStateChange: State.endAddSettlement,\r\n    beginStateChange: State.beginAddSettlement,\r\n    finishMessage: ({ islandName }) => {\r\n      return `a settlement was raised in ${islandName}!`\r\n      },\r\n    cost: ActionCosts[ActionTypes.AddSettlement],\r\n    validate: validateAddSettlement,\r\n    getDuration: () => 40,\r\n    getName: task => `settlement`\r\n    */\r\n  },\r\n\r\n  [ActionTypes.AddGarden]: {\r\n    text: 'plant garden',\r\n    emoji: '🥬'\r\n    /*    beginStateChange: State.beginAddGarden,\r\n    endStateChange: State.endAddGarden,\r\n    finishMessage: ({ islandName }) => `a garden was planted in ${islandName}!`,\r\n    cost: ActionCosts[ActionTypes.AddGarden],\r\n    validate: validateAddGarden,\r\n    getDuration: () => 40,\r\n    getName: task => `garden`\r\n  */\r\n  },\r\n\r\n  [ActionTypes.AddTemple]: {\r\n    text: 'build temple',\r\n    emoji: '🙏'\r\n    /*    beginStateChange: State.beginAddTemple,\r\n    endStateChange: State.endAddTemple,\r\n    cost: ActionCosts[ActionTypes.AddGarden],\r\n    finishMessage: ({ islandName }) => `a temple was built in ${islandName}!`,\r\n    validate: validateAddTemple,\r\n    getDuration: () => 100,\r\n    getName: task => `temple`\r\n  */\r\n  }\r\n}\r\n\r\nexport { Actions, ActionCosts, ActionTypes }\r\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\serviceWorker.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Locations.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\IslandProperties.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\App.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\island\\properties.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\cell\\cellSlice.js",["264"],"import { createSlice, createSelector } from '@reduxjs/toolkit'\nimport { generateIsland } from '../island/generateIsland'\nimport world from '../island/world'\nimport { CellTypes, maxTiles } from '../island/properties'\n\nexport const cellSlice = createSlice({\n  name: 'cell',\n  initialState: {\n    byId: {},\n    activatableByIslandId: {}, // stores the ids of cells that can be activated. */\n    deactivatableByIslandId: {} /* stores the ids of activated cells that can be deactivated. */,\n    activatedByIslandId: {} /* stores the ids of cells that have been activated */,\n    harbourByIslandId: {} /* stores the ids of cells that are harbours */,\n    byCellGroupId: {}\n  },\n  reducers: {\n    resetIsland: (state, action) => {\n      const { islandId } = action.payload\n      state.activatableByIslandId[islandId] = []\n      state.deactivatableByIslandId[islandId] = []\n      state.activatedByIslandId[islandId] = []\n      state.harbourByIslandId[islandId] = []\n    },\n    generateGrid: (state, action) => {\n      const { islandId } = action.payload\n      const { size } = world[islandId]\n      const cells = generateIsland(size)\n\n      state.activatableByIslandId[islandId] = []\n      state.deactivatableByIslandId[islandId] = []\n      state.activatedByIslandId[islandId] = []\n      state.harbourByIslandId[islandId] = []\n\n      cells.forEach(cell => {\n        const col = cell.pos % size\n        const row = Math.floor(cell.pos / size)\n        const id = `${islandId}:${row}_${col}`\n\n        let neighbours = {}\n        if (col > 0) neighbours['n'] = `${islandId}:${row}_${col - 1}`\n        if (col < size - 1) neighbours['s'] = `${islandId}:${row}_${col + 1}`\n        if (row > 0) neighbours['w'] = `${islandId}:${row - 1}_${col}`\n        if (row < size - 1) neighbours['e'] = `${islandId}:${row + 1}_${col}`\n\n        state.byId[id] = {\n          ...cell,\n          id,\n          row,\n          col,\n          islandId,\n          neighbours\n        }\n      })\n    },\n    yieldResource: {\n      reducer: (state, action) => {},\n      prepare: properties => {\n        const log = true\n        return { payload: { log, ...properties } }\n      }\n    },\n    toggleActivated: (state, action) => {\n      const { cellId } = action.payload\n      const islandId = cellId.split(':')[0]\n\n      const activatedCells = () => state.activatedByIslandId[islandId]\n      const deactivatableCells = () => state.deactivatableByIslandId[islandId]\n      const activatableCells = () => state.activatableByIslandId[islandId]\n\n      const cellActivated = () => activatedCells().indexOf(cellId) !== -1\n      const cellNeighbourIds = () =>\n        Object.entries(state.byId[cellId].neighbours).map(([dir, id]) => id)\n      const cellCanDeactivate = () =>\n        deactivatableCells().indexOf(cellId) !== -1\n      const cellCanActivate = () =>\n        (activatableCells().indexOf(cellId) !== -1 ||\n          activatableCells().length === 0) &&\n        activatedCells().length < maxTiles(world[islandId].size)\n\n      if (cellActivated() && cellCanDeactivate()) {\n        /** * Deactivating ***\n\n        /* Manage activated */\n        // mark the cell deactivated and activatable\n        const activatedCellRemovedUpdate = activatedCells().filter(\n          otherId => otherId !== cellId\n        )\n        state.activatedByIslandId[islandId] = activatedCellRemovedUpdate\n\n        if (\n          activatableCells().indexOf(cellId) === -1 &&\n          activatedCells().length !== 0\n        ) {\n          state.activatableByIslandId[islandId].push(cellId)\n        }\n\n        /* Manage activatable */\n        // for each neighbour, check if that cell still has at least 1 neighbour.\n        cellNeighbourIds().forEach(neighbourId => {\n          const secondNeighbourIds = Object.entries(\n            state.byId[neighbourId].neighbours\n          ).map(([dir, id]) => id)\n\n          const numActiveNeighbours = secondNeighbourIds.filter(\n            secondNeighbourId =>\n              activatedCells().indexOf(secondNeighbourId) !== -1\n          ).length\n\n          // remove the neighbour if it has been left with no active neighbours\n          if (numActiveNeighbours === 0) {\n            state.activatableByIslandId[islandId] = activatableCells().filter(\n              otherId => otherId !== neighbourId\n            )\n          }\n        })\n      } else if (!cellActivated() && cellCanActivate()) {\n        /** * Activating ***/\n        /* Manage activated */\n\n        // mark the cell activated and activatable\n        state.activatedByIslandId[islandId].push(cellId)\n        state.activatableByIslandId[islandId] = activatableCells().filter(\n          id => id !== cellId\n        )\n\n        /* Manage activatable */\n        // mark all non-activated neighbours of this cell as activatable\n        cellNeighbourIds().forEach(neighbourId => {\n          if (\n            activatableCells().indexOf(neighbourId) === -1 &&\n            activatedCells().indexOf(neighbourId) === -1\n          ) {\n            state.activatableByIslandId[islandId].push(neighbourId)\n          }\n        })\n      }\n\n      /* Manage unactivatable\n         For every activated cell on the same island,\n         run the bfs search for connected components\n         (after above changes have taken place)\n       */\n\n      let deactivatableUpdate = []\n\n      activatedCells().forEach(id => {\n        let bfsQueue = []\n        let visited = {}\n        let current = null\n        let allowDeactivate = false\n\n        // simulate removing this id.\n        const deactivatedSimulation = activatedCells().filter(\n          otherId => otherId !== id\n        )\n\n        if (deactivatedSimulation.length === 0) {\n          // cell is the only one activated.\n          allowDeactivate = true\n        } else {\n          bfsQueue.push(deactivatedSimulation[0])\n          while (bfsQueue.length > 0) {\n            current = bfsQueue.shift()\n            if (!visited[current]) {\n              visited[current] = true\n              // add activated neighbours to the queue\n              Object.entries(state.byId[current].neighbours)\n                .filter(\n                  ([dir, neighbourId]) =>\n                    deactivatedSimulation.indexOf(neighbourId) !== -1\n                )\n                .forEach(([dir, neighbourId]) => {\n                  bfsQueue.push(neighbourId)\n                })\n            }\n          }\n          // any activated cells on the same island that were not visited?\n          const unvisited = deactivatedSimulation.filter(\n            id => visited[id] == undefined\n          )\n          const connected = unvisited.length === 0\n          if (connected) {\n            allowDeactivate = true\n          }\n        }\n        if (allowDeactivate) {\n          deactivatableUpdate.push(id)\n        }\n      })\n\n      state.deactivatableByIslandId[islandId] = deactivatableUpdate\n\n      /* recompute harbours for this island */\n\n      state.harbourByIslandId[islandId] = activatableCells().filter(cellId => {\n        return (\n          Object.entries(state.byId[cellId].neighbours)\n            .map(([dir, neighbourId]) => neighbourId)\n            .reduce((acc, neighbourId) => {\n              return (\n                acc + (activatedCells().indexOf(neighbourId) === -1 ? 0 : 1)\n              )\n            }, 0) > 1\n        )\n      })\n    }\n  },\n  extraReducers: {\n    'cellGroup/create': (state, action) => {\n      //const { cellGroupId, islandId, polyomino, cellId } = action\n      // associate all the cells that fall under the given polyomino with a cellGroup\n\n    }\n  }\n})\n\nexport const {\n  generateGrid,\n  toggleActivated,\n  yieldResource,\n  resetIsland\n} = cellSlice.actions\n\nexport const selectCellById = state => state.cell.byId\n\nexport const selectCells2d = islandId =>\n  createSelector(\n    [selectCellById],\n    cells => {\n      const { size } = world[islandId]\n      const nDimension = [...Array(size).keys()]\n\n      // only return a result when the island has been generated.\n      if (cells[`${islandId}:0_0`] === undefined) {\n        return undefined\n      }\n\n      return nDimension.map(row =>\n        nDimension.map(col => cells[`${islandId}:${row}_${col}`])\n      )\n    }\n  )\n\nexport const selectDeactivatableIds = islandId => state =>\n  state.cell.deactivatableByIslandId[islandId] || []\n\nexport const selectActivatableIds = islandId => state =>\n  state.cell.activatableByIslandId[islandId] || []\n\nexport const selectActivatedIds = islandId => state =>\n  state.cell.activatedByIslandId[islandId] || []\n\nexport const selectHarbourIds = islandId => state =>\n  state.cell.harbourByIslandId[islandId] || []\n\n// assumes the island size does not change\nexport const selectRemainingActivations = islandId =>\n  createSelector(\n    [selectActivatedIds(islandId)],\n    cellIds => maxTiles(world[islandId].size) - cellIds.length\n  )\n\n// assuming celltype can change through the course of the game\nexport const selectIslandHasMountain = islandId =>\n  createSelector(\n    [selectActivatedIds(islandId), selectCellById],\n    (cellIds, cells) =>\n      cellIds.reduce(\n        (acc, id) => acc || cells[id].cellType === CellTypes.Mountain,\n        false\n      )\n  )\n\nexport const yieldResourceAsync = thing => dispatch =>\n  dispatch(yieldResource(thing))\n\nexport default cellSlice.reducer\n","C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\features\\polyomino\\polyominoSlice.js",[],"C:\\Users\\arron\\Desktop\\dev\\shellscatter\\src\\app\\Theme.js",[],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\index.js",[],["265","266"],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\App.js",["267"],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\serviceWorker.js",[],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\app\\store.js",[],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\islandSlice.js",["268"],"import { createSlice, createSelector } from '@reduxjs/toolkit'\nimport world from './world'\n\nconst initialIslandById = Object.fromEntries(\n  Object.entries(world).map(([islandId, island]) => {\n    return [\n      islandId,\n      {\n        ...island\n      }\n    ]\n  })\n)\n\nexport const islandSlice = createSlice({\n  name: 'island',\n  initialState: {\n    byId: initialIslandById\n  }\n})\n\nexport default islandSlice.reducer\n\nexport const { confirmIsland } = islandSlice.actions\n\nexport const allCellsActivated = islandId => state =>\n  state.island.byId[islandId].remainingActivations === 0\n\nexport const noCellsActivated = islandId => state =>\n  state.island.byId[islandId].remainingActivations ===\n  state.island.byId[islandId].size\n\nexport const selectIslandById = islandId => state => state.island.byId[islandId]\n","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\cell\\cellSlice.js",["269"],"import { createSlice, createSelector } from '@reduxjs/toolkit'\nimport { generateIsland } from '../island/generateIsland'\nimport world from '../island/world'\nimport { CellTypes, maxTiles } from '../island/properties'\n\nexport const cellSlice = createSlice({\n  name: 'cell',\n  initialState: {\n    byId: {},\n    activatableByIslandId: {}, // stores the ids of cells that can be activated. */\n    deactivatableByIslandId: {} /* stores the ids of activated cells that can be deactivated. */,\n    activatedByIslandId: {} /* stores the ids of cells that have been activated */,\n    harbourByIslandId: {} /* stores the ids of cells that are harbours */\n  },\n  reducers: {\n    resetIsland: (state, action) => {\n      const { islandId } = action.payload\n      state.activatableByIslandId[islandId] = []\n      state.deactivatableByIslandId[islandId] = []\n      state.activatedByIslandId[islandId] = []\n      state.harbourByIslandId[islandId] = []\n    },\n    generateGrid: (state, action) => {\n      const { islandId } = action.payload\n      const { size } = world[islandId]\n      const cells = generateIsland(size)\n\n      state.activatableByIslandId[islandId] = []\n      state.deactivatableByIslandId[islandId] = []\n      state.activatedByIslandId[islandId] = []\n      state.harbourByIslandId[islandId] = []\n\n      cells.forEach(cell => {\n        const col = cell.pos % size\n        const row = Math.floor(cell.pos / size)\n        const id = `${islandId}:${row}_${col}`\n\n        let neighbours = {}\n        if (col > 0) neighbours['n'] = `${islandId}:${row}_${col - 1}`\n        if (col < size - 1) neighbours['s'] = `${islandId}:${row}_${col + 1}`\n        if (row > 0) neighbours['w'] = `${islandId}:${row - 1}_${col}`\n        if (row < size - 1) neighbours['e'] = `${islandId}:${row + 1}_${col}`\n\n        state.byId[id] = {\n          ...cell,\n          id,\n          row,\n          col,\n          islandId,\n          neighbours\n        }\n      })\n    },\n    toggleActivated: (state, action) => {\n      const { cellId } = action.payload\n      const islandId = cellId.split(':')[0]\n\n      const activatedCells = () => state.activatedByIslandId[islandId]\n      const deactivatableCells = () => state.deactivatableByIslandId[islandId]\n      const activatableCells = () => state.activatableByIslandId[islandId]\n\n      const cellActivated = () => activatedCells().indexOf(cellId) !== -1\n      const cellNeighbourIds = () =>\n        Object.entries(state.byId[cellId].neighbours).map(([dir, id]) => id)\n      const cellCanDeactivate = () =>\n        deactivatableCells().indexOf(cellId) !== -1\n      const cellCanActivate = () =>\n        (activatableCells().indexOf(cellId) !== -1 ||\n          activatableCells().length === 0) &&\n        activatedCells().length < maxTiles(world[islandId].size)\n\n      if (cellActivated() && cellCanDeactivate()) {\n        /** * Deactivating ***\n\n        /* Manage activated */\n        // mark the cell deactivated and activatable\n        const activatedCellRemovedUpdate = activatedCells().filter(\n          otherId => otherId !== cellId\n        )\n        state.activatedByIslandId[islandId] = activatedCellRemovedUpdate\n\n        if (\n          activatableCells().indexOf(cellId) === -1 &&\n          activatedCells().length !== 0\n        ) {\n          state.activatableByIslandId[islandId].push(cellId)\n        }\n\n        /* Manage activatable */\n        // for each neighbour, check if that cell still has at least 1 neighbour.\n        cellNeighbourIds().forEach(neighbourId => {\n          const secondNeighbourIds = Object.entries(\n            state.byId[neighbourId].neighbours\n          ).map(([dir, id]) => id)\n\n          const numActiveNeighbours = secondNeighbourIds.filter(\n            secondNeighbourId =>\n              activatedCells().indexOf(secondNeighbourId) !== -1\n          ).length\n\n          // remove the neighbour if it has been left with no active neighbours\n          if (numActiveNeighbours === 0) {\n            state.activatableByIslandId[islandId] = activatableCells().filter(\n              otherId => otherId !== neighbourId\n            )\n          }\n        })\n      } else if (!cellActivated() && cellCanActivate()) {\n        /** * Activating ***/\n        /* Manage activated */\n\n        // mark the cell activated and activatable\n        state.activatedByIslandId[islandId].push(cellId)\n        state.activatableByIslandId[islandId] = activatableCells().filter(\n          id => id !== cellId\n        )\n\n        /* Manage activatable */\n        // mark all non-activated neighbours of this cell as activatable\n        cellNeighbourIds().forEach(neighbourId => {\n          if (\n            activatableCells().indexOf(neighbourId) === -1 &&\n            activatedCells().indexOf(neighbourId) === -1\n          ) {\n            state.activatableByIslandId[islandId].push(neighbourId)\n          }\n        })\n      }\n\n      /* Manage unactivatable\n         For every activated cell on the same island,\n         run the bfs search for connected components\n         (after above changes have taken place)\n       */\n\n      let deactivatableUpdate = []\n\n      activatedCells().forEach(id => {\n        let bfsQueue = []\n        let visited = {}\n        let current = null\n        let allowDeactivate = false\n\n        // simulate removing this id.\n        const deactivatedSimulation = activatedCells().filter(\n          otherId => otherId !== id\n        )\n\n        if (deactivatedSimulation.length === 0) {\n          // cell is the only one activated.\n          allowDeactivate = true\n        } else {\n          bfsQueue.push(deactivatedSimulation[0])\n          while (bfsQueue.length > 0) {\n            current = bfsQueue.shift()\n            if (!visited[current]) {\n              visited[current] = true\n              // add activated neighbours to the queue\n              Object.entries(state.byId[current].neighbours)\n                .filter(\n                  ([dir, neighbourId]) =>\n                    deactivatedSimulation.indexOf(neighbourId) !== -1\n                )\n                .forEach(([dir, neighbourId]) => {\n                  bfsQueue.push(neighbourId)\n                })\n            }\n          }\n          // any activated cells on the same island that were not visited?\n          const unvisited = deactivatedSimulation.filter(\n            id => visited[id] == undefined\n          )\n          const connected = unvisited.length === 0\n          if (connected) {\n            allowDeactivate = true\n          }\n        }\n        if (allowDeactivate) {\n          deactivatableUpdate.push(id)\n        }\n      })\n\n      state.deactivatableByIslandId[islandId] = deactivatableUpdate\n\n      /* recompute harbours for this island */\n\n      state.harbourByIslandId[islandId] = activatableCells().filter(cellId => {\n        return (\n          Object.entries(state.byId[cellId].neighbours)\n            .map(([dir, neighbourId]) => neighbourId)\n            .reduce((acc, neighbourId) => {\n              return (\n                acc + (activatedCells().indexOf(neighbourId) === -1 ? 0 : 1)\n              )\n            }, 0) > 1\n        )\n      })\n    }\n  }\n})\n\nexport const {\n  generateGrid,\n  toggleActivated,\n  yieldResource,\n  resetIsland\n} = cellSlice.actions\n\nexport const selectCellById = state => state.cell.byId\n\nexport const selectCellsByIsland = islandId_ => state =>\n  Object.values(state.cell.byId).filter(\n    ({ islandId }) => islandId === islandId_\n  )\n\nexport const selectCells2d = islandId =>\n  createSelector([selectCellById], cells => {\n    const { size } = world[islandId]\n    const nDimension = [...Array(size).keys()]\n\n    // only return a result when the island has been generated.\n    if (cells[`${islandId}:0_0`] === undefined) {\n      return undefined\n    }\n\n    return nDimension.map(row =>\n      nDimension.map(col => cells[`${islandId}:${row}_${col}`])\n    )\n  })\n\nexport const selectDeactivatableIds = islandId => state =>\n  state.cell.deactivatableByIslandId[islandId] || []\n\nexport const selectActivatableIds = islandId => state =>\n  state.cell.activatableByIslandId[islandId] || []\n\nexport const selectActivatedIds = islandId => state =>\n  state.cell.activatedByIslandId[islandId] || []\n\nexport const selectHarbourIds = islandId => state =>\n  state.cell.harbourByIslandId[islandId] || []\n\n// assumes the island size does not change\nexport const selectRemainingActivations = islandId =>\n  createSelector(\n    [selectActivatedIds(islandId)],\n    cellIds => maxTiles(world[islandId].size) - cellIds.length\n  )\n\n// assuming celltype can change through the course of the game\nexport const selectIslandHasMountain = islandId =>\n  createSelector(\n    [selectActivatedIds(islandId), selectCellById],\n    (cellIds, cells) =>\n      cellIds.reduce(\n        (acc, id) => acc || cells[id].cellType === CellTypes.Mountain,\n        false\n      )\n  )\n\nexport default cellSlice.reducer\n","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\world.js",["270"],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\properties.js",[],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\generateIsland.js",["271","272","273"],"import { CellTypes } from './properties'\nimport * as Poisson from 'poisson-disk-sampling'\nimport {\n  ResourceTypes,\n  FoodPerResources,\n  WoodPerResources\n} from '../../app/Resources'\n\nconst GridPositions = (grid, size) => {\n  const u = pos => pos - size\n  const d = pos => pos + size\n  const l = pos => (pos % size === 0 ? undefined : pos - 1)\n  const r = pos => (pos % size === size - 1 ? undefined : pos + 1)\n\n  const up = pos => grid[u(pos)]\n  const down = pos => grid[d(pos)]\n  const left = pos => grid[l(pos)]\n  const right = pos => grid[r(pos)]\n\n  const upright = pos => grid[u(r(pos))]\n  const downleft = pos => grid[d(l(pos))]\n  const upleft = pos => grid[u(l(pos))]\n  const downright = pos => grid[d(r(pos))]\n\n  return { up, down, left, right, upright, downleft, upleft, downright }\n}\n\nconst randomChoice = arr => {\n  let index = Math.floor(Math.random() * arr.length)\n  return arr[index]\n}\n\nconst rand = (min, max) => Math.floor(Math.random() * (max - min + 1) + min)\n\nconst materialResources = Object.values(ResourceTypes).filter(x => {\n  return WoodPerResources[x] > 0\n})\nconst foodResources = Object.values(ResourceTypes).filter(\n  x => FoodPerResources[x] > 0\n)\nconst allResources = Object.values(ResourceTypes)\n\nconst buildCell = (cellType, neighbourCells) => {\n  let contains = []\n  if (cellType === CellTypes.Materials) {\n    contains = [\n      randomChoice(materialResources),\n      randomChoice(materialResources)\n    ]\n  } else if (cellType === CellTypes.Food) {\n    contains = [randomChoice(foodResources), randomChoice(foodResources)]\n  } else if (cellType === CellTypes.Desert) {\n    contains = [\n      randomChoice([\n        ResourceTypes.BushFood,\n        ResourceTypes.Coconuts,\n        null,\n        null,\n        null\n      ])\n    ].filter(x => x !== null)\n  } else if (cellType === CellTypes.Lagoon) {\n    contains = [\n      randomChoice([ResourceTypes.FreshWater, null]),\n      randomChoice([ResourceTypes.Fish, null])\n    ].filter(x => x !== null)\n  } else if (cellType === CellTypes.Mountain) {\n    contains = [\n      randomChoice([\n        ResourceTypes.FreshWater,\n        ResourceTypes.Birds,\n        ResourceTypes.Bamboo,\n        null\n      ])\n    ].filter(x => x !== null)\n  } else {\n    contains = [randomChoice(allResources)]\n  }\n  return { cellType, contains }\n}\n\nexport const generateIsland = size => {\n  const baseCell = {\n    cellType: CellTypes.Undecided\n  }\n\n  const getPos = (x, y) => y * size + x\n\n  let grid = Array(size * size)\n    .fill({ ...baseCell })\n    .map((cell, pos) => ({ ...cell, pos }))\n\n  const {\n    up,\n    down,\n    left,\n    right,\n    upleft,\n    upright,\n    downleft,\n    downright\n  } = GridPositions(grid, size)\n\n  // add size/3 settlements\n\n  for (let i = 0; i < size / 4; i++) {\n    let x = rand(0, size - 1)\n    let y = rand(0, size - 1)\n    let cell = grid[getPos(x, y)]\n    grid[getPos(x, y)] = { ...cell, cellType: CellTypes.Settlement }\n  }\n\n  // add at least 1 food next to a settlement.\n  // find a settlement, pick a random direction that leads to another cell, place food.\n  const sPos = randomChoice(\n    grid.filter(cell => cell.cellType === CellTypes.Settlement)\n  ).pos\n  const essentialFoodCandidates = [\n    up(sPos),\n    down(sPos),\n    left(sPos),\n    right(sPos)\n  ].filter(x => x != undefined && x.cellType === CellTypes.Undecided)\n  const essentialFood = randomChoice(essentialFoodCandidates)\n\n  grid[essentialFood.pos] = {\n    ...essentialFood,\n    ...buildCell(CellTypes.Food)\n  }\n\n  const randomWalkUpdate = propertiesFn => {\n    let walk = [grid[sPos]]\n\n    let end = null\n    while (walk.length < size) {\n      let head = walk[walk.length - 1]\n      let candidates = [up, down, left, right]\n        .map(fn => fn(head.pos))\n        .filter(\n          x =>\n            x &&\n            (walk.length > 3\n              ? x.cellType === CellTypes.Undecided\n              : x.cellType !== CellTypes.Settlement &&\n                x.cellType !== CellTypes.Food) &&\n            walk.filter(w => w.pos === x.pos).length === 0\n        )\n      let pick = randomChoice(candidates)\n      if (pick) walk.push(pick)\n      else {\n        break\n      }\n    }\n    end = walk.pop()\n    grid[end.pos] = {\n      ...end,\n      ...propertiesFn([up, down, left, right].map(fn => fn(end.pos)))\n    }\n    return [...walk, end]\n  }\n\n  randomWalkUpdate(neighbours => buildCell(CellTypes.Materials, neighbours))\n\n  if (size > 5) {\n    randomWalkUpdate(neighbours => buildCell(CellTypes.Mountain, neighbours))\n  }\n\n  const desertRate = 1.5\n  const pDesert = new Poisson([size, size], size / desertRate)\n\n  pDesert\n    .fill()\n    .map(point => getPos(Math.round(point[0]), Math.round(point[1])))\n    .forEach(pos => {\n      if (grid[pos] && grid[pos].cellType === CellTypes.Undecided) {\n        // clump the desert cells together on von neumann neighbourhood\n        // alternate direction of pill shapes\n        let neighbours = [\n          up,\n          down,\n          left,\n          right,\n          ...randomChoice([\n            [upright, downleft],\n            [downright, upleft]\n          ])\n        ].map(fn => fn(pos))\n\n        let desertCount = 0\n        for (let neighbour of neighbours) {\n          if (neighbour && neighbour.cellType === CellTypes.Undecided) {\n            grid[neighbour.pos] = {\n              ...grid[neighbour.pos],\n              ...buildCell(CellTypes.Desert)\n            }\n            desertCount += 1\n          }\n        }\n        // oasis :)\n        grid[pos] = {\n          ...grid[pos],\n          ...buildCell(desertCount === 6 ? CellTypes.Lagoon : CellTypes.Desert)\n        }\n      }\n    })\n\n  const pMountains = new Poisson([size, size], size / 4)\n\n  pMountains\n    .fill()\n    .map(point => getPos(Math.round(point[0]), Math.round(point[1])))\n    .forEach(pos => {\n      let noOtherMountains =\n        [left, right, up, down]\n          .map(fn => fn(pos))\n          .filter(nn => nn == undefined || nn.cellType === CellTypes.Mountain)\n          .length === 0\n\n      if (\n        grid[pos] &&\n        grid[pos].cellType === CellTypes.Undecided &&\n        noOtherMountains\n      ) {\n        grid[pos] = { ...grid[pos], ...buildCell(CellTypes.Mountain, []) } // todo\n        let neighbours = [upright(pos), downleft(pos)]\n        for (let neighbour of neighbours) {\n          if (neighbour && neighbour.cellType === CellTypes.Undecided) {\n            let others = [up, down, left, right].map(fn => fn(neighbour.pos))\n            let noOtherMountains =\n              others.filter(\n                nn => nn == undefined || nn.cellType === CellTypes.Mountain\n              ).length === 0\n            if (noOtherMountains) {\n              grid[neighbour.pos] = {\n                ...grid[neighbour.pos],\n                ...buildCell(CellTypes.Mountain, [])\n              } // todo\n            }\n          }\n        }\n      }\n    })\n\n  const pGrass = new Poisson([size, size], size / 12)\n\n  pGrass\n    .fill()\n    .map(point => getPos(Math.round(point[0]), Math.round(point[1])))\n    .forEach(pos => {\n      if (grid[pos] && grid[pos].cellType === CellTypes.Undecided) {\n        grid[pos] = { ...grid[pos], ...buildCell(CellTypes.Grass) }\n      }\n    })\n\n  grid.forEach(cell => {\n    if (cell.cellType === CellTypes.Undecided) {\n      grid[cell.pos] = {\n        ...cell,\n        ...buildCell(\n          randomChoice([\n            CellTypes.Food,\n            CellTypes.Food,\n            CellTypes.Materials,\n            CellTypes.Desert,\n            CellTypes.Desert,\n            CellTypes.Lagoon\n            // CellTypes.Undecided\n          ])\n        )\n      }\n    }\n  })\n\n  return grid\n}\n","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\app\\Resources.js",[],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\game\\IslandGame.js",["274"],"import React, { useEffect } from 'react'\nimport { useDispatch } from 'react-redux'\nimport { IslandMap } from '../island/IslandMap'\nimport { generateGrid } from '../cell/cellSlice'\n\nexport function IslandGame ({ islandId }) {\n  const dispatch = useDispatch()\n  useEffect(() => {\n    dispatch(generateGrid({ islandId }))\n  }, [])\n\n  return <IslandMap islandId={islandId} />\n}\n","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\island\\IslandMap.js",["275","276","277","278","279","280","281"],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\cell\\Cell.js",["282","283","284","285","286","287","288","289"],"import React, { useState, useEffect } from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\nimport styles from './Cell.module.css'\nimport * as poissonProcess from 'poisson-process'\nimport { yieldResourceAsync } from '../cell/cellSlice'\nimport { Grid, Button, Segment } from 'semantic-ui-react'\nimport { CellTypes } from '../island/properties'\n\nconst extraStyles = {\n  gridColumnStyle: {\n    padding: '0px'\n  },\n  segmentStyle: {\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    margin: '0px',\n    width: '30px',\n    height: '30px',\n    fontSize: '1.4em'\n  }\n}\n\nexport function IslandCell (props) {\n  const {\n    showAsLink,\n    cellActivated,\n    canActivate,\n    allActivated,\n    isHarbour,\n    cell,\n    onCellClick,\n    isOcean,\n    noneActivated,\n    isTopLeft,\n    isTopRight,\n    isBottomLeft,\n    isBottomRight\n  } = props\n\n  // todo use styled-components\n  const classNameStr =\n    styles.cell +\n    (cellActivated\n      ? ` ${styles.cellActivated}`\n      : ` ${styles.cellUnactivated}`) +\n    (!showAsLink ? ` ${styles.cellBlocked}` : '') +\n    (!cellActivated && !canActivate && !noneActivated\n      ? ` ${styles.cellUnactivatable}`\n      : '') +\n    (cell.cellType === CellTypes.Settlement\n      ? ` ${styles.cellSettlement}`\n      : '') +\n    (canActivate ? ` ${styles.cellCanActivate}` : '') +\n    (isHarbour ? ` ${styles.cellHarbour}` : '') +\n    (isOcean ? ` ${styles.cellOcean}` : '') +\n    (noneActivated ? ` ${styles.noneActivated}` : '')\n\n  return (\n    <Grid.Column\n      key={cell.id}\n      onClick={() => onCellClick(cell)}\n      disabled={!showAsLink}\n      className={classNameStr}\n      style={{\n        transition: 'opacity 1s',\n        borderTopLeftRadius: isTopLeft ? '0.28rem' : '0px',\n        borderTopRightRadius: isTopRight ? '0.28rem' : '0px',\n        borderBottomLeftRadius: isBottomLeft ? '0.28rem' : '0px',\n        borderBottomRightRadius: isBottomRight ? '0.28rem' : '0px',\n        ...extraStyles.segmentStyle\n      }}\n    >\n      {((canActivate && !allActivated) ||\n        isHarbour ||\n        cellActivated ||\n        (noneActivated && cell.cellType === CellTypes.Settlement)) && (\n        <span\n          style={{ opacity:\n            isOcean\n              ? '0'\n              : cellActivated || noneActivated\n              ? '1'\n              : (isHarbour && allActivated) ? '0' \n              : '0.5',\n          }}\n        >\n          {cell.cellType}\n        </span>\n      )}\n    </Grid.Column>\n  )\n}\n","C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\notes\\Notes.js",[],"C:\\Users\\arron\\Desktop\\dev\\island-adaptation\\src\\features\\notes\\useNotes.js",["290"],"import { CellTypes } from '../island/properties'\r\nimport { useSelector } from 'react-redux'\r\nimport { selectIslandById } from '../island/islandSlice'\r\nimport {\r\n  selectActivatedIds,\r\n  selectHarbourIds,\r\n  selectCellsByIsland\r\n} from '../cell/cellSlice'\r\n\r\nexport function useNotes (islandId) {\r\n  let notes = []\r\n  let messages = []\r\n  let stuff = {}\r\n\r\n  const { id, size } = useSelector(selectIslandById(islandId))\r\n  const cells = useSelector(selectCellsByIsland(id))\r\n  const activatedCells = useSelector(selectActivatedIds(islandId))\r\n  const harbourCells = useSelector(selectHarbourIds(islandId))\r\n\r\n  const activatedNeighbours = cell =>\r\n    Object.values(cell.neighbours).filter(cellId =>\r\n      activatedCells.includes(cellId)\r\n    )\r\n\r\n  const oneSettlementActivated =\r\n    cells.filter(\r\n      ({ id, cellType }) =>\r\n        activatedCells.includes(id) && cellType === CellTypes.Settlement\r\n    ).length > 0\r\n\r\n  const lagoonWithFourNeighbours =\r\n    cells.filter(({ id, cellType, ...cell }) => {\r\n      if (activatedCells.includes(id) && cellType === CellTypes.Lagoon) {\r\n        return activatedNeighbours(cell).length === 4\r\n      } else {\r\n        return false\r\n      }\r\n    }).length > 0\r\n\r\n  if (oneSettlementActivated) {\r\n    if (oneSettlementActivated) messages.push('✔ settlement')\r\n  } else {\r\n    messages.push(\r\n      `need settlement (${CellTypes.Settlement})`\r\n    )\r\n  }\r\n\r\n  if (size > 2) {\r\n    // all settlements must be adjacent to two activated cells\r\n    let settlements = cells.filter(\r\n      ({ id, cellType }) =>\r\n        activatedCells.includes(id) && cellType === CellTypes.Settlement\r\n    )\r\n    let allHaveAdjacent =\r\n      settlements.length > 0 &&\r\n      settlements.filter(cell => {\r\n        return activatedNeighbours(cell).length > 1\r\n      }).length === settlements.length\r\n    if (allHaveAdjacent) {\r\n      messages.push('✔ two neighbours per settlement')\r\n    } else if (settlements.length > 0) {\r\n      messages.push('settlements need two neighbours')\r\n    }\r\n  }\r\n\r\n  if (size >= 8) {\r\n    const mountainActivated =\r\n      cells.filter(\r\n        ({ id, cellType }) =>\r\n          activatedCells.includes(id) && cellType === CellTypes.Mountain\r\n      ).length > 0\r\n    if (mountainActivated) messages.push('️✔ mountain')\r\n    else messages.push(`need one mountain (${CellTypes.Mountain})`)\r\n  }\r\n\r\n  cells.forEach(({ id, contains }) => {\r\n    if (activatedCells.includes(id) && contains && contains.length > 0) {\r\n      contains.forEach(\r\n        item => (stuff[item] = stuff[item] ? stuff[item] + 1 : 1)\r\n      )\r\n    }\r\n  })\r\n\r\n  const numHarbours = cells.filter(({ id }) => harbourCells.includes(id)).length\r\n  if (numHarbours > 0) {\r\n    notes.push(`${numHarbours} fishing harbour${numHarbours > 1 ? 's' : ''}`)\r\n  }\r\n\r\n  for (let [thing, num] of Object.entries(stuff)) {\r\n    notes.push(`${thing} ${num > 1 ? `x${num}` : ''}`)\r\n  }\r\n\r\n  return { messages, notes }\r\n}\r\n",{"ruleId":"291","replacedBy":"292"},{"ruleId":"293","replacedBy":"294"},{"ruleId":"295","severity":1,"message":"296","line":15,"column":22,"nodeType":"297","messageId":"298","endLine":15,"endColumn":26},{"ruleId":"295","severity":1,"message":"299","line":15,"column":40,"nodeType":"297","messageId":"298","endLine":15,"endColumn":46},{"ruleId":"300","severity":1,"message":"301","line":1,"column":1,"nodeType":"302","endLine":18,"endColumn":2},{"ruleId":"295","severity":1,"message":"303","line":1,"column":17,"nodeType":"297","messageId":"298","endLine":1,"endColumn":25},{"ruleId":"295","severity":1,"message":"304","line":1,"column":27,"nodeType":"297","messageId":"298","endLine":1,"endColumn":36},{"ruleId":"295","severity":1,"message":"305","line":2,"column":10,"nodeType":"297","messageId":"298","endLine":2,"endColumn":21},{"ruleId":"295","severity":1,"message":"306","line":4,"column":13,"nodeType":"297","messageId":"298","endLine":4,"endColumn":27},{"ruleId":"295","severity":1,"message":"307","line":5,"column":10,"nodeType":"297","messageId":"298","endLine":5,"endColumn":28},{"ruleId":"295","severity":1,"message":"308","line":13,"column":5,"nodeType":"297","messageId":"298","endLine":13,"endColumn":17},{"ruleId":"295","severity":1,"message":"309","line":23,"column":9,"nodeType":"297","messageId":"298","endLine":23,"endColumn":17},{"ruleId":"295","severity":1,"message":"310","line":25,"column":9,"nodeType":"297","messageId":"298","endLine":25,"endColumn":18},{"ruleId":"311","severity":1,"message":"312","line":32,"column":6,"nodeType":"313","endLine":32,"endColumn":8,"suggestions":"314"},{"ruleId":"295","severity":1,"message":"303","line":1,"column":17,"nodeType":"297","messageId":"298","endLine":1,"endColumn":25},{"ruleId":"295","severity":1,"message":"304","line":1,"column":27,"nodeType":"297","messageId":"298","endLine":1,"endColumn":36},{"ruleId":"295","severity":1,"message":"305","line":2,"column":10,"nodeType":"297","messageId":"298","endLine":2,"endColumn":21},{"ruleId":"295","severity":1,"message":"315","line":4,"column":16,"nodeType":"297","messageId":"298","endLine":4,"endColumn":19},{"ruleId":"295","severity":1,"message":"316","line":4,"column":21,"nodeType":"297","messageId":"298","endLine":4,"endColumn":24},{"ruleId":"291","replacedBy":"317"},{"ruleId":"293","replacedBy":"318"},{"ruleId":"319","severity":1,"message":"320","line":61,"column":21,"nodeType":"321","messageId":"322","endLine":61,"endColumn":23},{"ruleId":"319","severity":1,"message":"320","line":66,"column":21,"nodeType":"321","messageId":"322","endLine":66,"endColumn":23},{"ruleId":"319","severity":1,"message":"320","line":116,"column":19,"nodeType":"321","messageId":"322","endLine":116,"endColumn":21},{"ruleId":"319","severity":1,"message":"323","line":209,"column":28,"nodeType":"321","messageId":"322","endLine":209,"endColumn":30},{"ruleId":"319","severity":1,"message":"323","line":224,"column":26,"nodeType":"321","messageId":"322","endLine":224,"endColumn":28},{"ruleId":"295","severity":1,"message":"324","line":1,"column":10,"nodeType":"297","messageId":"298","endLine":1,"endColumn":24},{"ruleId":"295","severity":1,"message":"325","line":4,"column":7,"nodeType":"297","messageId":"298","endLine":4,"endColumn":19},{"ruleId":"295","severity":1,"message":"304","line":1,"column":27,"nodeType":"297","messageId":"298","endLine":1,"endColumn":36},{"ruleId":"295","severity":1,"message":"326","line":4,"column":8,"nodeType":"297","messageId":"298","endLine":4,"endColumn":14},{"ruleId":"295","severity":1,"message":"327","line":6,"column":10,"nodeType":"297","messageId":"298","endLine":6,"endColumn":14},{"ruleId":"295","severity":1,"message":"316","line":6,"column":21,"nodeType":"297","messageId":"298","endLine":6,"endColumn":24},{"ruleId":"295","severity":1,"message":"328","line":6,"column":26,"nodeType":"297","messageId":"298","endLine":6,"endColumn":32},{"ruleId":"295","severity":1,"message":"329","line":6,"column":34,"nodeType":"297","messageId":"298","endLine":6,"endColumn":43},{"ruleId":"295","severity":1,"message":"330","line":6,"column":45,"nodeType":"297","messageId":"298","endLine":6,"endColumn":50},{"ruleId":"295","severity":1,"message":"331","line":2,"column":8,"nodeType":"297","messageId":"298","endLine":2,"endColumn":13},{"ruleId":"295","severity":1,"message":"304","line":1,"column":27,"nodeType":"297","messageId":"298","endLine":1,"endColumn":36},{"ruleId":"295","severity":1,"message":"326","line":5,"column":8,"nodeType":"297","messageId":"298","endLine":5,"endColumn":14},{"ruleId":"295","severity":1,"message":"327","line":7,"column":3,"nodeType":"297","messageId":"298","endLine":7,"endColumn":7},{"ruleId":"295","severity":1,"message":"332","line":16,"column":3,"nodeType":"297","messageId":"298","endLine":16,"endColumn":13},{"ruleId":"295","severity":1,"message":"333","line":36,"column":9,"nodeType":"297","messageId":"298","endLine":36,"endColumn":15},{"ruleId":"295","severity":1,"message":"334","line":97,"column":10,"nodeType":"297","messageId":"298","endLine":97,"endColumn":17},{"ruleId":"295","severity":1,"message":"335","line":97,"column":19,"nodeType":"297","messageId":"298","endLine":97,"endColumn":29},{"ruleId":"295","severity":1,"message":"336","line":4,"column":10,"nodeType":"297","messageId":"298","endLine":4,"endColumn":22},{"ruleId":"295","severity":1,"message":"337","line":10,"column":49,"nodeType":"297","messageId":"298","endLine":10,"endColumn":56},{"ruleId":"295","severity":1,"message":"338","line":16,"column":9,"nodeType":"297","messageId":"298","endLine":16,"endColumn":13},{"ruleId":"311","severity":1,"message":"339","line":59,"column":6,"nodeType":"313","endLine":59,"endColumn":8,"suggestions":"340"},{"ruleId":"295","severity":1,"message":"341","line":1,"column":23,"nodeType":"297","messageId":"298","endLine":1,"endColumn":37},{"ruleId":"295","severity":1,"message":"342","line":6,"column":10,"nodeType":"297","messageId":"298","endLine":6,"endColumn":24},{"ruleId":"343","severity":1,"message":"344","line":107,"column":15,"nodeType":"345","messageId":"346","endLine":107,"endColumn":29},{"ruleId":"311","severity":1,"message":"347","line":153,"column":6,"nodeType":"313","endLine":153,"endColumn":22,"suggestions":"348"},{"ruleId":"295","severity":1,"message":"349","line":155,"column":9,"nodeType":"297","messageId":"298","endLine":155,"endColumn":17},{"ruleId":"295","severity":1,"message":"341","line":1,"column":23,"nodeType":"297","messageId":"298","endLine":1,"endColumn":37},{"ruleId":"295","severity":1,"message":"350","line":66,"column":26,"nodeType":"297","messageId":"298","endLine":66,"endColumn":33},{"ruleId":"295","severity":1,"message":"351","line":46,"column":7,"nodeType":"297","messageId":"298","endLine":46,"endColumn":19},{"ruleId":"295","severity":1,"message":"352","line":64,"column":7,"nodeType":"297","messageId":"298","endLine":64,"endColumn":24},{"ruleId":"295","severity":1,"message":"353","line":71,"column":7,"nodeType":"297","messageId":"298","endLine":71,"endColumn":20},{"ruleId":"295","severity":1,"message":"354","line":73,"column":5,"nodeType":"297","messageId":"298","endLine":73,"endColumn":15},{"ruleId":"319","severity":1,"message":"323","line":179,"column":31,"nodeType":"321","messageId":"322","endLine":179,"endColumn":33},{"ruleId":"291","replacedBy":"355"},{"ruleId":"293","replacedBy":"356"},{"ruleId":"295","severity":1,"message":"357","line":7,"column":7,"nodeType":"297","messageId":"298","endLine":7,"endColumn":13},{"ruleId":"295","severity":1,"message":"341","line":1,"column":23,"nodeType":"297","messageId":"298","endLine":1,"endColumn":37},{"ruleId":"319","severity":1,"message":"323","line":171,"column":31,"nodeType":"321","messageId":"322","endLine":171,"endColumn":33},{"ruleId":"300","severity":1,"message":"301","line":1,"column":1,"nodeType":"302","endLine":18,"endColumn":2},{"ruleId":"319","severity":1,"message":"320","line":123,"column":19,"nodeType":"321","messageId":"322","endLine":123,"endColumn":21},{"ruleId":"319","severity":1,"message":"323","line":216,"column":28,"nodeType":"321","messageId":"322","endLine":216,"endColumn":30},{"ruleId":"319","severity":1,"message":"323","line":231,"column":26,"nodeType":"321","messageId":"322","endLine":231,"endColumn":28},{"ruleId":"311","severity":1,"message":"358","line":10,"column":6,"nodeType":"313","endLine":10,"endColumn":8,"suggestions":"359"},{"ruleId":"295","severity":1,"message":"303","line":1,"column":17,"nodeType":"297","messageId":"298","endLine":1,"endColumn":25},{"ruleId":"295","severity":1,"message":"360","line":4,"column":10,"nodeType":"297","messageId":"298","endLine":4,"endColumn":14},{"ruleId":"295","severity":1,"message":"361","line":4,"column":16,"nodeType":"297","messageId":"298","endLine":4,"endColumn":20},{"ruleId":"295","severity":1,"message":"337","line":4,"column":22,"nodeType":"297","messageId":"298","endLine":4,"endColumn":29},{"ruleId":"295","severity":1,"message":"362","line":14,"column":3,"nodeType":"297","messageId":"298","endLine":14,"endColumn":17},{"ruleId":"295","severity":1,"message":"363","line":15,"column":3,"nodeType":"297","messageId":"298","endLine":15,"endColumn":22},{"ruleId":"295","severity":1,"message":"357","line":19,"column":7,"nodeType":"297","messageId":"298","endLine":19,"endColumn":13},{"ruleId":"295","severity":1,"message":"303","line":1,"column":17,"nodeType":"297","messageId":"298","endLine":1,"endColumn":25},{"ruleId":"295","severity":1,"message":"304","line":1,"column":27,"nodeType":"297","messageId":"298","endLine":1,"endColumn":36},{"ruleId":"295","severity":1,"message":"305","line":2,"column":10,"nodeType":"297","messageId":"298","endLine":2,"endColumn":21},{"ruleId":"295","severity":1,"message":"364","line":2,"column":23,"nodeType":"297","messageId":"298","endLine":2,"endColumn":34},{"ruleId":"295","severity":1,"message":"306","line":4,"column":13,"nodeType":"297","messageId":"298","endLine":4,"endColumn":27},{"ruleId":"295","severity":1,"message":"307","line":5,"column":10,"nodeType":"297","messageId":"298","endLine":5,"endColumn":28},{"ruleId":"295","severity":1,"message":"328","line":6,"column":16,"nodeType":"297","messageId":"298","endLine":6,"endColumn":22},{"ruleId":"295","severity":1,"message":"337","line":6,"column":24,"nodeType":"297","messageId":"298","endLine":6,"endColumn":31},{"ruleId":"295","severity":1,"message":"365","line":31,"column":9,"nodeType":"297","messageId":"298","endLine":31,"endColumn":33},"no-native-reassign",["366"],"no-negated-in-lhs",["367"],"no-unused-vars","'year' is assigned a value but never used.","Identifier","unusedVar","'paused' is assigned a value but never used.","import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","'useState' is defined but never used.","'useEffect' is defined but never used.","'useSelector' is defined but never used.","'poissonProcess' is defined but never used.","'yieldResourceAsync' is defined but never used.","'allActivated' is assigned a value but never used.","'dispatch' is assigned a value but never used.","'yieldRate' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'event', 'id', and 'ongoingText'. Either include them or remove the dependency array.","ArrayExpression",["368"],"'Row' is defined but never used.","'Col' is defined but never used.",["366"],["367"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","'appendLogAsync' is defined but never used.","'stripFromLog' is assigned a value but never used.","'styles' is defined but never used.","'Card' is defined but never used.","'Button' is defined but never used.","'Statistic' is defined but never used.","'Space' is defined but never used.","'world' is defined but never used.","'PageHeader' is defined but never used.","'island' is assigned a value but never used.","'avatars' is assigned a value but never used.","'setAvatars' is assigned a value but never used.","'generateGrid' is defined but never used.","'Segment' is defined but never used.","'tags' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'dispatch'. Either include it or remove the dependency array.",["369"],"'createSelector' is defined but never used.","'islandsDetails' is defined but never used.","no-script-url","Script URL is a form of eval.","Literal","unexpectedScriptURL","React Hook useEffect has a missing dependency: 'renderMap'. Either include it or remove the dependency array. Mutable values like 'svgRef.current' aren't valid dependencies because mutating them doesn't re-render the component.",["370"],"'reRender' is assigned a value but never used.","'islands' is assigned a value but never used.","'finishVoyage' is assigned a value but never used.","'getVoyageDuration' is assigned a value but never used.","'getVoyageName' is assigned a value but never used.","'actionType' is assigned a value but never used.",["366"],["367"],"'styles' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'dispatch' and 'islandId'. Either include them or remove the dependency array.",["371"],"'Grid' is defined but never used.","'List' is defined but never used.","'selectCellById' is defined but never used.","'selectCellsByIsland' is defined but never used.","'useDispatch' is defined but never used.","'lagoonWithFourNeighbours' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"372","fix":"373"},{"desc":"374","fix":"375"},{"desc":"376","fix":"377"},{"desc":"378","fix":"379"},"Update the dependencies array to be: [event, id, ongoingText]",{"range":"380","text":"381"},"Update the dependencies array to be: [dispatch]",{"range":"382","text":"383"},"Update the dependencies array to be: [renderMap]",{"range":"384","text":"385"},"Update the dependencies array to be: [dispatch, islandId]",{"range":"386","text":"387"},[948,950],"[event, id, ongoingText]",[1864,1866],"[dispatch]",[3594,3610],"[renderMap]",[324,326],"[dispatch, islandId]"]